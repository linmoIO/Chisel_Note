---

layout: docs

title:  "Deep Dive into <> and := Connection Operators"

section: "chisel3"

---

# Deep Dive into Connection Operators

Chisel contains two connection operators, `:=` and `<>`. This document provides a deeper explanation of the differences of the two and when to use one or the other. The differences are demonstrated with experiments using Scastie examples which use `DecoupledIO`.



### Experiment Setup

```scala
// Imports used by the following examples
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage
```

The diagram for the experiment can be viewed [here](https://docs.google.com/document/d/14C918Hdahk2xOGSJJBT-ZVqAx99_hg3JQIq-vaaifQU/edit?usp=sharing).
![Experiment Image](https://raw.githubusercontent.com/chipsalliance/chisel3/master/docs/src/images/connection-operators-experiment.svg?sanitize=true)

```scala

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect Producer to IO
  p.io.a <> io.in
  // connect producer to consumer
  c.io.a <> p.io.b
  // connect consumer to IO
  io.out <> c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b <> io.a
}
```
Below we can see the resulting Verilog for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// res0: String = """// Generated by CIRCT firtool-1.43.0
// module PipelineStage(	// <stdin>:3:10, :10:10
//   input        io_a_valid,	// connection-operators.md:37:14
//   input  [7:0] io_a_bits,	// connection-operators.md:37:14
//   input        io_b_ready,	// connection-operators.md:37:14
//   output       io_a_ready,	// connection-operators.md:37:14
//                io_b_valid,	// connection-operators.md:37:14
//   output [7:0] io_b_bits	// connection-operators.md:37:14
// );
// 
//   assign io_a_ready = io_b_ready;	// <stdin>:3:10, :10:10
//   assign io_b_valid = io_a_valid;	// <stdin>:3:10, :10:10
//   assign io_b_bits = io_a_bits;	// <stdin>:3:10, :10:10
// endmodule
// 
// module Wrapper(	// <stdin>:17:10
//   input        clock,	// <stdin>:18:11
//                reset,	// <stdin>:19:11
//                io_in_valid,	// connection-operators.md:21:14
//   input  [7:0] io_in_bits,	// connection-operators.md:21:14
//   input        io_out_ready,	// connection-operators.md:21:14
//   output       io_in_ready,	// connection-operators.md:21:14
//                io_out_valid,	// connection-operators.md:21:14
//   output [7:0] io_out_bits	// connection-operators.md:21:14
// );
// 
//   wire       _c_io_a_ready;	// connection-operators.md:26:17
//   wire       _p_io_b_valid;	// connection-operators.md:25:17
//   wire [7:0] _p_io_b_bits;	// connection-operators.md:25:17
//   PipelineStage p (	// connection-operators.md:25:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready),	// connection-operators.md:26:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (	// connection-operators.md:26:17
//     .io_a_valid (_p_io_b_valid),	// connection-operators.md:25:17
//     .io_a_bits  (_p_io_b_bits),	// connection-operators.md:25:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// """
```
## Concept 1: `<>` is Commutative



This experiment is set up to test for the function of `<>` using the experiment above.

Achieving this involves flipping the RHS and LHS of the `<>` operator and seeing how `<>`  will react.
( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/LVhlbkFQQnq7X3trHfgZZQ )




```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  io.in <> p.io.a
  // connect producer  to consumer
  p.io.b <> c.io.a
  // connect consumer to I/O
  c.io.b <> io.out
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a <> io.b
}
```
Below we can see the resulting Verilog for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// res2: String = """// Generated by CIRCT firtool-1.43.0
// module PipelineStage(	// <stdin>:3:10, :10:10
//   input        io_a_valid,	// connection-operators.md:83:14
//   input  [7:0] io_a_bits,	// connection-operators.md:83:14
//   input        io_b_ready,	// connection-operators.md:83:14
//   output       io_a_ready,	// connection-operators.md:83:14
//                io_b_valid,	// connection-operators.md:83:14
//   output [7:0] io_b_bits	// connection-operators.md:83:14
// );
// 
//   assign io_a_ready = io_b_ready;	// <stdin>:3:10, :10:10
//   assign io_b_valid = io_a_valid;	// <stdin>:3:10, :10:10
//   assign io_b_bits = io_a_bits;	// <stdin>:3:10, :10:10
// endmodule
// 
// module Wrapper(	// <stdin>:17:10
//   input        clock,	// <stdin>:18:11
//                reset,	// <stdin>:19:11
//                io_in_valid,	// connection-operators.md:67:14
//   input  [7:0] io_in_bits,	// connection-operators.md:67:14
//   input        io_out_ready,	// connection-operators.md:67:14
//   output       io_in_ready,	// connection-operators.md:67:14
//                io_out_valid,	// connection-operators.md:67:14
//   output [7:0] io_out_bits	// connection-operators.md:67:14
// );
// 
//   wire       _c_io_a_ready;	// connection-operators.md:72:17
//   wire       _p_io_b_valid;	// connection-operators.md:71:17
//   wire [7:0] _p_io_b_bits;	// connection-operators.md:71:17
//   PipelineStage p (	// connection-operators.md:71:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready),	// connection-operators.md:72:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (	// connection-operators.md:72:17
//     .io_a_valid (_p_io_b_valid),	// connection-operators.md:71:17
//     .io_a_bits  (_p_io_b_bits),	// connection-operators.md:71:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// """
```
### Conclusion:
The Verilog remained the same without incurring errors, showing that the `<>` operator is commutative.




## Concept 2: `:=` means assign ALL LHS signals from the RHS, regardless of the direction on the LHS.
Using the same experiment code as above, we set to test for the function of `:=`
We replace all instances of `<>` with `:=` in the sample code above.
(Scastie link to the experiment: https://scastie.scala-lang.org/Shorla/o1ShdaY3RWKf0IIFwwQ1UQ/1)

```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  p.io.a := io.in
  // connect producer  to consumer
  c.io.a := p.io.b
  // connect consumer to I/O
  io.out := c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a := io.b
}
```
Below we can see the resulting error message for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// chisel3.package$ChiselException: Connection between sink (PipelineStage.io.a: IO[DecoupledIO]) and source (PipelineStage.io.b: IO[DecoupledIO]) failed @: .bitsio.a.bits in PipelineStage cannot be written from module PipelineStage.
// 	at ... ()
// 	at repl.MdocSession$MdocApp3$PipelineStage.<init>(connection-operators.md:133)
// 	at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30$$anonfun$apply$20.apply(connection-operators.md:117)
// 	at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30$$anonfun$apply$20.apply(connection-operators.md:117)
// 	at chisel3.Module$.do_apply(Module.scala:54)
// 	at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30.apply(connection-operators.md:117)
// 	at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30.apply(connection-operators.md:117)
// 	at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
// 	at repl.MdocSession$MdocApp3$Wrapper.<init>(connection-operators.md:117)
// 	at repl.MdocSession$MdocApp3$$anonfun$39$$anonfun$apply$25.apply(connection-operators.md:141)
// 	at repl.MdocSession$MdocApp3$$anonfun$39$$anonfun$apply$25.apply(connection-operators.md:141)
// 	at ... ()
// 	at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
```
### Conclusion:
The := operator goes field-by-field on the LHS and attempts to connect it to the same-named signal from the RHS. If something on the LHS is actually an Input, or the corresponding signal on the RHS is an Output, you will get an error as shown above.

## Concept 3: Always Use `:=` to assign DontCare to Wires
When assigning `DontCare` to something that is not directioned, should you use `:=` or `<>`?
We will find out using the sample codes below:
( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1)

```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  //connect Producer to IO
  io.in := DontCare
  p.io.a <> DontCare
  val tmp = Wire(Flipped(DecoupledIO(UInt(8.W))))
  tmp := DontCare
  p.io.a <> io.in
  // connect producer to consumer
  c.io.a <> p.io.b
  //connect consumer to IO
  io.out <> c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b <> io.a
}
```
Below we can see the resulting Verilog for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// res5: String = """// Generated by CIRCT firtool-1.43.0
// module PipelineStage(	// <stdin>:3:10, :10:10
//   input        io_a_valid,	// connection-operators.md:183:14
//   input  [7:0] io_a_bits,	// connection-operators.md:183:14
//   input        io_b_ready,	// connection-operators.md:183:14
//   output       io_a_ready,	// connection-operators.md:183:14
//                io_b_valid,	// connection-operators.md:183:14
//   output [7:0] io_b_bits	// connection-operators.md:183:14
// );
// 
//   assign io_a_ready = io_b_ready;	// <stdin>:3:10, :10:10
//   assign io_b_valid = io_a_valid;	// <stdin>:3:10, :10:10
//   assign io_b_bits = io_a_bits;	// <stdin>:3:10, :10:10
// endmodule
// 
// module Wrapper(	// <stdin>:17:10
//   input        clock,	// <stdin>:18:11
//                reset,	// <stdin>:19:11
//                io_in_valid,	// connection-operators.md:163:14
//   input  [7:0] io_in_bits,	// connection-operators.md:163:14
//   input        io_out_ready,	// connection-operators.md:163:14
//   output       io_in_ready,	// connection-operators.md:163:14
//                io_out_valid,	// connection-operators.md:163:14
//   output [7:0] io_out_bits	// connection-operators.md:163:14
// );
// 
//   wire       _c_io_a_ready;	// connection-operators.md:168:17
//   wire       _p_io_b_valid;	// connection-operators.md:167:17
//   wire [7:0] _p_io_b_bits;	// connection-operators.md:167:17
//   PipelineStage p (	// connection-operators.md:167:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready),	// connection-operators.md:168:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (	// connection-operators.md:168:17
//     .io_a_valid (_p_io_b_valid),	// connection-operators.md:167:17
//     .io_a_bits  (_p_io_b_bits),	// connection-operators.md:167:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// """
```
### Conclusion:
If `<>` were used to assign the unidrectioned wire `tmp` to DontCare, we would get an error. But in the example above, we used `:=` and no errors occurred.
But when `:=` was used to assign the wire to DontCare, no errors will occur.

Thus, when assigning `DontCare` to a `Wire`, always use `:=`.


##  Concept 4: You can use `<>` or `:=` to assign `DontCare` to directioned things (IOs)
When assigning `DontCare` to something that is directioned, should you use `:=` or `<>`?
We will find out using the sample codes below:
( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1)

```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  //connect Producer to IO
  io.in := DontCare
  p.io.a <> DontCare
  val tmp = Wire(Flipped(DecoupledIO(UInt(8.W))))
  tmp := DontCare
  p.io.a <> io.in
  // connect producer to consumer
  c.io.a <> p.io.b
  //connect consumer to IO
  io.out <> c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b <> io.a
}
```
Below we can see the resulting Verilog for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// res7: String = """// Generated by CIRCT firtool-1.43.0
// module PipelineStage(	// <stdin>:3:10, :10:10
//   input        io_a_valid,	// connection-operators.md:233:14
//   input  [7:0] io_a_bits,	// connection-operators.md:233:14
//   input        io_b_ready,	// connection-operators.md:233:14
//   output       io_a_ready,	// connection-operators.md:233:14
//                io_b_valid,	// connection-operators.md:233:14
//   output [7:0] io_b_bits	// connection-operators.md:233:14
// );
// 
//   assign io_a_ready = io_b_ready;	// <stdin>:3:10, :10:10
//   assign io_b_valid = io_a_valid;	// <stdin>:3:10, :10:10
//   assign io_b_bits = io_a_bits;	// <stdin>:3:10, :10:10
// endmodule
// 
// module Wrapper(	// <stdin>:17:10
//   input        clock,	// <stdin>:18:11
//                reset,	// <stdin>:19:11
//                io_in_valid,	// connection-operators.md:213:14
//   input  [7:0] io_in_bits,	// connection-operators.md:213:14
//   input        io_out_ready,	// connection-operators.md:213:14
//   output       io_in_ready,	// connection-operators.md:213:14
//                io_out_valid,	// connection-operators.md:213:14
//   output [7:0] io_out_bits	// connection-operators.md:213:14
// );
// 
//   wire       _c_io_a_ready;	// connection-operators.md:218:17
//   wire       _p_io_b_valid;	// connection-operators.md:217:17
//   wire [7:0] _p_io_b_bits;	// connection-operators.md:217:17
//   PipelineStage p (	// connection-operators.md:217:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready),	// connection-operators.md:218:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (	// connection-operators.md:218:17
//     .io_a_valid (_p_io_b_valid),	// connection-operators.md:217:17
//     .io_a_bits  (_p_io_b_bits),	// connection-operators.md:217:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// """
```
### Conclusion:
Both `<>` and `:=` can be used to assign directioned things (IOs) to DontCare as shown in `io.in` and `p.io.a` respectively. This is basically equivalent because in this case both `<>` and `:=` will determine the direction from the LHS.


## Concept 5: `<>`  works between things with at least one known flow (An IO or child's IO).

If there is at least one known flow what will `<>` do? This will be shown using the experiment code below:
( Scastie link for the experiment:https://scastie.scala-lang.org/Shorla/gKx9ReLVTTqDTk9vmw5ozg)

```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  //connect Producer to IO
    // For this experiment, we add a temporary wire and see if it works...
  //p.io.a <> io.in
  val tmp = Wire(DecoupledIO(UInt(8.W)))
  // connect intermediate wire
  tmp <> io.in
  p.io.a <> tmp
  // connect producer to consumer
  c.io.a <> p.io.b
  //connect consumer to IO
  io.out <> c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b <> io.a
}
```
Below we can see the resulting Verilog for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// res9: String = """// Generated by CIRCT firtool-1.43.0
// module PipelineStage(	// <stdin>:3:10, :10:10
//   input        io_a_valid,	// connection-operators.md:284:14
//   input  [7:0] io_a_bits,	// connection-operators.md:284:14
//   input        io_b_ready,	// connection-operators.md:284:14
//   output       io_a_ready,	// connection-operators.md:284:14
//                io_b_valid,	// connection-operators.md:284:14
//   output [7:0] io_b_bits	// connection-operators.md:284:14
// );
// 
//   assign io_a_ready = io_b_ready;	// <stdin>:3:10, :10:10
//   assign io_b_valid = io_a_valid;	// <stdin>:3:10, :10:10
//   assign io_b_bits = io_a_bits;	// <stdin>:3:10, :10:10
// endmodule
// 
// module Wrapper(	// <stdin>:17:10
//   input        clock,	// <stdin>:18:11
//                reset,	// <stdin>:19:11
//                io_in_valid,	// connection-operators.md:263:14
//   input  [7:0] io_in_bits,	// connection-operators.md:263:14
//   input        io_out_ready,	// connection-operators.md:263:14
//   output       io_in_ready,	// connection-operators.md:263:14
//                io_out_valid,	// connection-operators.md:263:14
//   output [7:0] io_out_bits	// connection-operators.md:263:14
// );
// 
//   wire       _c_io_a_ready;	// connection-operators.md:268:17
//   wire       _p_io_b_valid;	// connection-operators.md:267:17
//   wire [7:0] _p_io_b_bits;	// connection-operators.md:267:17
//   PipelineStage p (	// connection-operators.md:267:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready),	// connection-operators.md:268:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (	// connection-operators.md:268:17
//     .io_a_valid (_p_io_b_valid),	// connection-operators.md:267:17
//     .io_a_bits  (_p_io_b_bits),	// connection-operators.md:267:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// """
```
### Conclusion:
The connection above went smoothly with no errors, this goes to show `<>` will work as long as there is at least one directioned thing (IO or submodule's IO) to "fix" the direction.


## Concept 6: `<>` and `:=` connect signals by field name.
This experiment creates a MockDecoupledIO which has the same fields by name as a DecoupledIO. Chisel lets us connect it and produces the same verilog, even though MockDecoupledIO and DecoupledIO are different types.
( Scastie link for the experiment:https://scastie.scala-lang.org/Uf4tQquvQYigZAW705NFIQ)

```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class MockDecoupledIO extends Bundle {
  val valid = Output(Bool())
  val ready = Input(Bool())
  val bits = Output(UInt(8.W))
}
class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(new MockDecoupledIO())
  val out = new MockDecoupledIO()
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  p.io.a <> io.in
  // connect producer  to consumer
  c.io.a <> p.io.b
  // connect consumer to I/O
  io.out <> c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a <> io.b
}
```
Below we can see the resulting Verilog for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// res11: String = """// Generated by CIRCT firtool-1.43.0
// module PipelineStage(	// <stdin>:3:10, :10:10
//   input        io_a_valid,	// connection-operators.md:337:14
//   input  [7:0] io_a_bits,	// connection-operators.md:337:14
//   input        io_b_ready,	// connection-operators.md:337:14
//   output       io_a_ready,	// connection-operators.md:337:14
//                io_b_valid,	// connection-operators.md:337:14
//   output [7:0] io_b_bits	// connection-operators.md:337:14
// );
// 
//   assign io_a_ready = io_b_ready;	// <stdin>:3:10, :10:10
//   assign io_b_valid = io_a_valid;	// <stdin>:3:10, :10:10
//   assign io_b_bits = io_a_bits;	// <stdin>:3:10, :10:10
// endmodule
// 
// module Wrapper(	// <stdin>:17:10
//   input        clock,	// <stdin>:18:11
//                reset,	// <stdin>:19:11
//                io_in_valid,	// connection-operators.md:321:14
//   input  [7:0] io_in_bits,	// connection-operators.md:321:14
//   input        io_out_ready,	// connection-operators.md:321:14
//   output       io_in_ready,	// connection-operators.md:321:14
//                io_out_valid,	// connection-operators.md:321:14
//   output [7:0] io_out_bits	// connection-operators.md:321:14
// );
// 
//   wire       _c_io_a_ready;	// connection-operators.md:326:17
//   wire       _p_io_b_valid;	// connection-operators.md:325:17
//   wire [7:0] _p_io_b_bits;	// connection-operators.md:325:17
//   PipelineStage p (	// connection-operators.md:325:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready),	// connection-operators.md:326:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (	// connection-operators.md:326:17
//     .io_a_valid (_p_io_b_valid),	// connection-operators.md:325:17
//     .io_a_bits  (_p_io_b_bits),	// connection-operators.md:325:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// """
```
And here is another experiment, where we remove one of the fields of MockDecoupledIO:
( Scastie link for the experiment:https://scastie.scala-lang.org/ChtkhKCpS9CvJkjjqpdeIA)

```scala
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class MockDecoupledIO extends Bundle {
  val valid = Output(Bool())
  val ready = Input(Bool())
  //val bits = Output(UInt(8.W))
}
class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(new MockDecoupledIO())
  val out = new MockDecoupledIO()
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  p.io.a <> io.in
  // connect producer  to consumer
  c.io.a <> p.io.b
  // connect consumer to I/O
  io.out <> c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a <> io.b
}
```
Below we can see the resulting error for this example:
```scala
ChiselStage.emitSystemVerilog(new Wrapper)
// chisel3.package$ChiselException: Connection between left (PipelineStage.io.a: IO[DecoupledIO]) and source (Wrapper.io.in: IO[MockDecoupledIO]) failed @.bits: Right Record missing field (bits).
// 	at ... ()
// 	at repl.MdocSession$MdocApp12$Wrapper.<init>(connection-operators.md:381)
// 	at repl.MdocSession$MdocApp12$$anonfun$119$$anonfun$apply$79.apply(connection-operators.md:402)
// 	at repl.MdocSession$MdocApp12$$anonfun$119$$anonfun$apply$79.apply(connection-operators.md:402)
// 	at ... ()
// 	at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
```
This one fails because there is a field `bits` missing.

### Conclusion:
For `:=`, the Scala types do not need to match but all the signals on the LHS must be provided by the RHS or you will get a Chisel elaboration error. There may be additional signals on the RHS, these will be ignored. For `<>`, the Scala types do not need to match, but all signals must match exactly between LHS and RHS. In both cases, the order of the fields does not matter.
